{"version":3,"sources":["services/urql-graphql-client.service.ts","../../src/Injector.ts","../../src/index.tsx","App.tsx","index.tsx"],"names":["GRAPHQL_API","UrqlGraphQLService","useQuery","useMutation","Injector","constructor","dependencies","parentInjector","dependencyGraph","dep","this","registerProvider","provide","configs","markDependencies","deps","e","parentDep","Error","instance","getConstructorFunc","Object","constructorFunc","getNodeData","providerToken","resolveDependencies","providerConfig","inject","service","InjectorContext","React","InjectorContextProvider","children","value","injector","providers","withProviders","component","providerList","injectorContext","Component","compDeps","InjectorContextConsumer","withInjector","client","createClient","url","AnimeCharacterPage","lazy","appProviders","useValue","StrictMode","Suspense","fallback","basename","path","exact","to","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a9c94755.chunk.js","sourcesContent":["import { useMutation, useQuery } from 'urql'\r\n\r\nexport const GRAPHQL_API = 'GraphQLService'\r\n\r\nexport const UrqlGraphQLService = {\r\n  useQuery,\r\n  useMutation\r\n}\r\n","/* eslint-disable new-cap */\r\nimport { DepGraph, DepGraphCycleError } from 'dependency-graph'\r\nimport { ConstructorProvider, InjectionToken, Provider, ProviderConfigs } from './provider.type'\r\n\r\nexport class Injector {\r\n  private dependencyGraph = new DepGraph<any>()\r\n\r\n  constructor(dependencies: Provider[] = [], private parentInjector: Injector | null = null) {\r\n    dependencies.forEach((dep: any) => this.registerProvider(dep))\r\n    this.resolveDependencies()\r\n  }\r\n\r\n  private registerProvider(dependency: Provider): void {\r\n    const { provide: providerToken, ...configs } = dependency\r\n    this.dependencyGraph.addNode(providerToken, configs)\r\n  }\r\n\r\n  private markDependencies(): void {\r\n    this.dependencyGraph\r\n      .overallOrder()\r\n      .map((dep) => [dep, this.dependencyGraph.getNodeData(dep)])\r\n      .forEach(([token, configs]) => {\r\n        const deps = (configs as any).deps ? (configs as any).deps : []\r\n\r\n        deps.forEach((dep: string) => {\r\n          try {\r\n            this.dependencyGraph.addDependency(token, dep)\r\n          } catch (e) {\r\n            if (e instanceof DepGraphCycleError) {\r\n              throw e\r\n            }\r\n            if ((e as Error).message.includes('Node does not exist')) {\r\n              let parentInjector = this.parentInjector\r\n              let parentDep\r\n              while (parentInjector) {\r\n                try {\r\n                  parentDep = parentInjector.inject(dep)\r\n                  break\r\n                } catch (e) {\r\n                  parentInjector = parentInjector.parentInjector\r\n                }\r\n              }\r\n\r\n              if (parentDep) {\r\n                this.dependencyGraph.addNode(dep, { instance: parentDep })\r\n                this.dependencyGraph.addDependency(token, dep)\r\n              } else {\r\n                throw new Error(`Could not resolve dependency: ${dep} for Injectable: ${token}`)\r\n              }\r\n            }\r\n          }\r\n        })\r\n      })\r\n  }\r\n\r\n  private getConstructorFunc(providerToken: string, providerConfig: ProviderConfigs): Function {\r\n    let constructorFunc\r\n    if (Object.prototype.hasOwnProperty.call(providerConfig, 'useClass')) {\r\n      constructorFunc = (...deps: any) => {\r\n        return new (\r\n          this.dependencyGraph.getNodeData(providerToken) as ConstructorProvider\r\n        ).useClass({ deps })\r\n      }\r\n    }\r\n\r\n    if (Object.prototype.hasOwnProperty.call(providerConfig, 'useFactory')) {\r\n      constructorFunc = this.dependencyGraph.getNodeData(providerToken).useFactory\r\n    }\r\n\r\n    if (Object.prototype.hasOwnProperty.call(providerConfig, 'useValue')) {\r\n      constructorFunc = () => this.dependencyGraph.getNodeData(providerToken).useValue\r\n    }\r\n\r\n    return constructorFunc\r\n  }\r\n\r\n  private resolveDependencies(): void {\r\n    this.markDependencies()\r\n\r\n    this.dependencyGraph.overallOrder().forEach((providerToken: string) => {\r\n      const providerConfig = this.dependencyGraph.getNodeData(providerToken)\r\n\r\n      const constructorFunc = this.getConstructorFunc(providerToken, providerConfig)\r\n\r\n      let deps = (providerConfig as any).deps ? (providerConfig as any).deps : []\r\n      deps = deps.map((dep: string) => this.dependencyGraph.getNodeData(dep).instance)\r\n\r\n      if (providerConfig?.instance == null) {\r\n        const instance = constructorFunc(...deps)\r\n\r\n        this.dependencyGraph.setNodeData(providerToken, {\r\n          ...providerConfig,\r\n          instance\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  public inject(service: InjectionToken) {\r\n    const dep = this.dependencyGraph.getNodeData(service).instance\r\n\r\n    if (!dep) {\r\n      throw new Error(`Could not find provider :${service}`)\r\n    }\r\n\r\n    return dep\r\n  }\r\n}\r\n","import React, { JSXElementConstructor, MemoExoticComponent, ReactElement } from 'react'\r\nimport { Injector } from './Injector'\r\nimport { Provider } from './provider.type'\r\n\r\ntype InjectorContextType = {\r\n  injector: Injector\r\n}\r\n\r\nconst InjectorContext = React.createContext<InjectorContextType | null>(null)\r\n\r\nexport type InjectorContextProviderProps = {\r\n  providers: Provider[]\r\n  children: React.ReactElement<any>\r\n}\r\n\r\nexport const InjectorContextProvider = ({ providers, children }: InjectorContextProviderProps) => {\r\n  const parentInjector = React.useContext(InjectorContext)\r\n\r\n  return (\r\n    <InjectorContext.Provider\r\n      value={{ injector: new Injector(providers, parentInjector?.injector) }}\r\n    >\r\n      {children}\r\n    </InjectorContext.Provider>\r\n  )\r\n}\r\n\r\nconst InjectorContextConsumer = ({\r\n  component: Component,\r\n  providerList\r\n}: {\r\n  component: any\r\n  providerList: string[]\r\n}): React.ReactElement<any | { deps: any[] }> => {\r\n  const injectorContext = React.useContext(InjectorContext)\r\n\r\n  const injector = injectorContext?.injector\r\n  if (!injector) {\r\n    throw new Error(\r\n      `withProviders used without Injector Context Provider. \r\n      Cannot locate providers: ${providerList}\r\n      `\r\n    )\r\n  }\r\n\r\n  const [compDeps] = React.useState(() =>\r\n    providerList.map((dep: any) => {\r\n      return injector.inject(dep)\r\n    })\r\n  )\r\n\r\n  if (!React.isValidElement(Component)) {\r\n    Component = React.createElement(Component)\r\n  }\r\n\r\n  return React.cloneElement(Component, {\r\n    ...Component.props,\r\n\r\n    deps: compDeps\r\n  } as any)\r\n}\r\n\r\nexport const withProviders = <T extends unknown>(\r\n  component: T,\r\n  providerList: string[]\r\n): MemoExoticComponent<() => ReactElement<any, string | JSXElementConstructor<any>>> => {\r\n  return React.memo(() => InjectorContextConsumer({ component, providerList }))\r\n}\r\n\r\nexport const withInjector = (Component: any, providers: Provider[]) => {\r\n  if (React.isValidElement(Component)) {\r\n    return React.memo(() => {\r\n      return <InjectorContextProvider providers={providers}>{Component}</InjectorContextProvider>\r\n    })\r\n  }\r\n\r\n  return React.memo(() => {\r\n    return (\r\n      <InjectorContextProvider providers={providers}>\r\n        <Component />\r\n      </InjectorContextProvider>\r\n    )\r\n  })\r\n}\r\n\r\nexport type { Provider } from './provider.type'\r\n// eslint-disable-next-line prettier/prettier\r\n\r\n","import { Provider, withInjector } from '@doughtnerd/wrangler-di'\r\nimport React from 'react'\r\nimport { HashRouter, Redirect, Route, Switch } from 'react-router-dom'\r\nimport { createClient, Provider as UrqlProvider } from 'urql'\r\nimport { GRAPHQL_API, UrqlGraphQLService } from './services/urql-graphql-client.service'\r\n\r\nconst client = createClient({\r\n  url: 'https://graphql.anilist.co'\r\n})\r\n\r\nconst AnimeCharacterPage = React.lazy(() => import('./pages/AnimeCharacterPage'))\r\n\r\n\r\nconst appProviders: Provider[] = [\r\n  { provide: GRAPHQL_API, useValue: UrqlGraphQLService }\r\n]\r\n\r\nconst App = () => {\r\n  return (\r\n    <React.StrictMode>\r\n      <UrqlProvider value={client}>\r\n        <React.Suspense fallback={<div>Loading...</div>}>\r\n          <HashRouter basename=\"/\">\r\n            <Switch>\r\n              <Route path={'/'} exact>\r\n                <Redirect to=\"/anime-character-details\"></Redirect>\r\n              </Route>\r\n              <Route path={'/anime-character-details'} exact component={AnimeCharacterPage}></Route>\r\n            </Switch>\r\n          </HashRouter>\r\n        </React.Suspense>\r\n      </UrqlProvider>\r\n    </React.StrictMode>\r\n  )\r\n}\r\n\r\nexport default withInjector(App, appProviders)\r\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}